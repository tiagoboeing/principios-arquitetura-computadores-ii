; I/O Address Bus decode - every device gets 0x200 addresses */

IO0  EQU  0000h
IO1  EQU  0200h
IO2  EQU  0400h
IO3  EQU  0600h
IO4  EQU  0800h
IO5  EQU  0A00h
IO6  EQU  0C00h
IO7  EQU  0E00h
IO8  EQU  1000h
IO9  EQU  1200h
IO10 EQU  1400h
IO11 EQU  1600h
IO12 EQU  1800h
IO13 EQU  1A00h
IO14 EQU  1C00h
IO15 EQU  1E00h

ADR_USART_DATA EQU  (IO4 + 00h) ; 800H
;ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

ADR_USART_CMD  EQU  (IO4 + 02h) ; 802H
;É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251

ADR_USART_STAT EQU  (IO4 + 02h) ; 802H
;RETORNA O STATUS SE UM CARACTER FOI DIGITADO
;RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL


;MEU CODIGO
code      SEGMENT 'code'
	  assume    CS:code,DS:data

	  org 0000h
;RESERVADO PARA VETOR DE INTERRUPCOES
	  org 0400h
;MEU CODIGO

INICIALIZA_8251:  ; 19200,8,N,1                                   
   MOV AL,0
   MOV DX, ADR_USART_CMD
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
   RET

MANDA_CARACTER:
   PUSHF
   PUSH DX
   PUSH AX  ; SALVA AL   

BUSY:
   MOV DX, ADR_USART_STAT
   IN  AL,DX
   TEST AL,1
   JZ BUSY
   MOV DX, ADR_USART_DATA
   POP AX  ; RESTAURA AL
   OUT DX,AL
   POP DX
   POPF
   RET

RECEBE_CARACTER: ; RETORNA EM AL O CARACTER DIGITADO
   PUSHF
   PUSH DX

AGUARDA_CARACTER:
   MOV DX, ADR_USART_STAT
   IN  AL,DX
   TEST AL,2
   JZ AGUARDA_CARACTER
   MOV DX, ADR_USART_DATA
   IN AL,DX
   SHR AL,1

NAO_RECEBIDO:
   POP DX
   POPF
   RET 

inicio:
    MOV AX,DATA
    MOV DS,AX

	CALL INICIALIZA_8251 	; PROGRAMA 19200,N,8,1

	MOV BX,OFFSET STRING 	; ENDEREÇO TEXTO DIGITADO
	MOV CX,0 				; CONT CARACTERES DIGITADOS
	CALL ROTINA_LE_TEXTO
	MOV AL,13
	CALL MANDA_CARACTER
	MOV AL,10
	CALL MANDA_CARACTER
	MOV BX, OFFSET STRING
	CALL MANDA_TEXTO

FIM:
	JMP FIM

LE_IO1:
	MOV DX, IO1
	IN AL,DX

	CMP AL,00B
	JE ESCREVE_ZERO
	CMP AL,01B
	JE ESCREVE_UM
	CMP AL,10B
	JE ESCREVE_DOIS
	CMP AL,11B
	JE ESCREVE_TRES

	JMP LE_IO1

ESCREVE_ZERO:
	MOV BX, OFFSET ZERO
	CALL MANDA_TEXTO
	JMP LE_IO1

ESCREVE_UM:
	MOV BX, OFFSET UM
	CALL MANDA_TEXTO
	JMP LE_IO1

ESCREVE_DOIS:
	MOV BX, OFFSET DOIS
	CALL MANDA_TEXTO
	JMP LE_IO1

ESCREVE_TRES:
	MOV BX, OFFSET TRES
	CALL MANDA_TEXTO
	JMP LE_IO1

MANDA_TEXTO:
	PUSHF
	PUSH AX 	;PRESERVA CONTEXTO

COMPARA_CARACTER:
	MOV AL,[BX]
	CMP AL,0 				; FIM DE TEXTO
	JE SAI_MANDA_TEXTO 		; SE SIM, SAI SUBPROGRAMA
	CALL MANDA_CARACTER 	; IMPRIME VALOR DE AL
	INC BX 					; APONTA PARA PROXIMO CARACTER
	JMP COMPARA_CARACTER

ROTINA_LE_TEXTO:
	PUSHF
	PUSH AX
	PUSH CX
	MOV CX, 0
	
LE_TEXTO:
	CALL RECEBE_CARACTER
	CMP AL,13 		; TECLA ENTER
	JE SAI_RECEBE_TEXTO
	CMP AL,8 		; TECLA BACKSPACE
	JE BACKSPACE
	CMP CX,64 		; SE FOR 64 CARACTERES --> LE_TEXTO
	JE LE_TEXTO
	CALL MANDA_CARACTER
	MOV [BX],AL
	INC BX
	INC CX 			; INFORMA QUE DIGITEI UM CARACTERE
	MOV AL,0
	MOV [BX],AL 	; NULL
	JMP LE_TEXTO
	DEC CX
	CMP CX,0
	JE SAI_RECEBE_TEXTO

FIM_LE_CARACTER:
	RET

BACKSPACE:
	CMP CX,0
	JE LE_TEXTO
	CALL MANDA_CARACTER
	DEC CX
	DEC BX
	MOV AL,0
	MOV [BX],AL
	JMP LE_TEXTO

SAI_RECEBE_TEXTO:
	RET 	; RETORNA PARA UMA LINHA DEPOIS DO CALL


SAI_MANDA_TEXTO:
	POP AX 	;RESTAURA CONTEXTO
	POPF
	RET 	; RETORNA PARA UMA LINHA DEPOIS DO CALL

code ends

;MILHA PILHA
STACK SEGMENT STACK      
DW 128 DUP(0) 
STACK ENDS 

;MEUS DADOS
DATA      SEGMENT  
	ZERO DB "ZERO",13,10,0
	UM 	 DB "UM",13,10,0
	DOIS DB "DOIS",13,10,0
	TRES DB "TRES",13,10,0
	STRING DB 64 DUP(0) ; DUPLICA ESPAÇOS x64
DATA      ENDS

end inicio
